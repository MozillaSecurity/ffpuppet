# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

import json
import logging
import os
import shutil
import tempfile
import time

from xml.etree import ElementTree

log = logging.getLogger("ffpuppet")  # pylint: disable=invalid-name

__author__ = "Tyson Smith"
__all__ = ("check_prefs", "create_profile", "poll_file")


def check_prefs(prof_prefs, input_prefs):
    """
    Check that the current prefs.js file in use by the browser contains all the requested prefs.

    NOTE: There will be false positives if input_prefs does not adhere to the formatting that
    is used in prefs.js file generated by the browser.

    @type prof_prefs: String
    @param prof_prefs: Path to profile prefs.js file

    @type input_prefs: String
    @param input_prefs: Path to prefs.js file that contains prefs that should be merged
                        into the prefs.js file generated by the browser

    @rtype: bool
    @return: True if all prefs in input_prefs are merged otherwise False
    """

    if not os.path.isfile(input_prefs):
        raise IOError("Cannot find %r" % input_prefs)
    if not os.path.isfile(prof_prefs):
        raise IOError("Cannot find %r" % prof_prefs)

    with open(prof_prefs, "r") as p_fp, open(input_prefs, "r") as i_fp:
        p_prefs = {pref.split(",")[0] for pref in p_fp if pref.startswith("user_pref(")}
        i_prefs = {pref.split(",")[0] for pref in i_fp if pref.startswith("user_pref(")}

    missing_prefs = i_prefs - p_prefs
    log.debug(
        "prefs not set %r",
        ", ".join([m_pref.lstrip("user_pref(") for m_pref in missing_prefs]))

    return not bool(missing_prefs)


def create_profile(extension=None, prefs_js=None, template=None):
    """
    Create a profile to be used with Firefox

    @type extension: String, or list of Strings
    @param extension: Path to an extension (e.g. DOMFuzz fuzzPriv extension) to be installed.

    @type prefs_js: String
    @param prefs_js: Path to a prefs.js file to install in the Firefox profile.

    @type template: String
    @param template: Path to an existing profile directory to use.

    @rtype: String
    @return: Path to directory to be used as a profile
    """

    profile = tempfile.mkdtemp(prefix="ffprof_")
    log.debug("profile directory: %r", profile)

    if template is not None:
        log.debug("using profile template: %r", template)
        shutil.rmtree(profile) # reuse the directory name
        if not os.path.isdir(template):
            raise IOError("Cannot find template profile: %r" % template)
        shutil.copytree(template, profile)
        invalid_prefs = os.path.join(profile, "Invalidprefs.js")
        # if Invalidprefs.js was copied from the template profile remove it
        if os.path.isfile(invalid_prefs):
            os.remove(invalid_prefs)

    if prefs_js is not None:
        log.debug("using prefs.js: %r", prefs_js)
        if not os.path.isfile(prefs_js):
            shutil.rmtree(profile, True) # clean up on failure
            raise IOError("prefs.js file does not exist: %r" % prefs_js)
        shutil.copyfile(prefs_js, os.path.join(profile, "prefs.js"))

        # times.json only needs to be created when using a custom pref.js
        times_json = os.path.join(profile, "times.json")
        if not os.path.isfile(times_json):
            with open(times_json, "w") as times_fp:
                times_fp.write('{"created":%d}' % (int(time.time()) * 1000))

    # extension support
    try:
        if extension is None:
            extensions = []
        elif isinstance(extension, (list, tuple)):
            extensions = extension
        else:
            extensions = [extension]
        if extensions and not os.path.isdir(os.path.join(profile, "extensions")):
            os.mkdir(os.path.join(profile, "extensions"))
        for ext in extensions:
            if os.path.isfile(ext) and ext.endswith(".xpi"):
                shutil.copyfile(
                    ext,
                    os.path.join(profile, "extensions", os.path.basename(ext)))
            elif os.path.isdir(ext):
                # read manifest to see what the folder should be named
                ext_name = None
                if os.path.isfile(os.path.join(ext, "manifest.json")):
                    try:
                        with open(os.path.join(ext, "manifest.json")) as manifest:
                            manifest = json.load(manifest)
                        ext_name = manifest["applications"]["gecko"]["id"]
                    except (IOError, KeyError, ValueError) as exc:
                        log.debug("Failed to parse manifest.json: %s", exc)
                elif os.path.isfile(os.path.join(ext, "install.rdf")):
                    try:
                        xmlns = {"x": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
                                 "em": "http://www.mozilla.org/2004/em-rdf#"}
                        tree = ElementTree.parse(os.path.join(ext, "install.rdf"))
                        assert tree.getroot().tag == "{%s}RDF" % xmlns["x"]
                        ids = tree.findall("./x:Description/em:id", namespaces=xmlns)
                        assert len(ids) == 1
                        ext_name = ids[0].text
                    except (AssertionError, IOError, ElementTree.ParseError) as exc:
                        log.debug("Failed to parse install.rdf: %s", exc)
                if ext_name is None:
                    raise RuntimeError("Failed to find extension id in manifest: %r" % ext)
                shutil.copytree(
                    os.path.abspath(ext),
                    os.path.join(profile, "extensions", ext_name))
            else:
                raise RuntimeError("Unknown extension: %r" % ext)
    except:
        shutil.rmtree(profile, True) # cleanup on failure
        raise
    return profile


def poll_file(filename, poll_rate=0.1, idle_wait=1.5, timeout=60):
    """
    Wait for file modification to complete. This is done by monitoring the
    last modified time of the specified file.
    NOTE: This depends on file system data being updated and this might not be uniform
    across platforms, even different file systems on the same platform may act differently.

    @type filename: String
    @param filename: Name of the file to poll.

    @type poll_rate: float
    @param poll_rate: Frequency to check the file modification time.

    @type idle_wait: float
    @param idle_wait: Amount of time that must elapse without file modification to exit.

    @type timeout: float
    @param timeout: Amount of time in seconds to poll, None will poll forever.

    @rtype: int
    @return: file size in bytes or None on failure/timeout.
    """

    assert timeout is None or timeout > idle_wait, "timeout must be greater than idle_wait time"
    assert poll_rate <= idle_wait, "poll_rate must be less then or equal to idle_wait"
    if not os.path.isfile(filename):
        log.debug("Cannot poll %r. File does not exist", filename)
        return None
    start_time = time.time()
    while time.time() - os.stat(filename).st_mtime < idle_wait:
        if timeout is not None and start_time + timeout < time.time():
            log.warning("%r was still being modified after %0.2f seconds", filename, timeout)
            return None
        time.sleep(poll_rate)
    return os.stat(filename).st_size
